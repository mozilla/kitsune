

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Details of Parallel Computing with IPython &mdash; IPython 0.11 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.11',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="IPython 0.11 documentation" href="../index.html" />
    <link rel="up" title="Using IPython for parallel computing" href="index.html" />
    <link rel="next" title="Transitioning from IPython.kernel to IPython.parallel" href="parallel_transition.html" />
    <link rel="prev" title="DAG Dependencies" href="dag_dependencies.html" /> 
  </head>
  <body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../index.html"><img src="../_static/logo.png" border="0" alt="IPython Documentation"/></a>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="parallel_transition.html" title="Transitioning from IPython.kernel to IPython.parallel"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="dag_dependencies.html" title="DAG Dependencies"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../search.html">search</a>|&nbsp;</li>
       <li><a href="../index.html">documentation </a> &raquo;</li>

          <li><a href="index.html" accesskey="U">Using IPython for parallel computing</a> &raquo;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Details of Parallel Computing with IPython</a><ul>
<li><a class="reference internal" href="#caveats">Caveats</a><ul>
<li><a class="reference internal" href="#non-copying-sends-and-numpy-arrays">Non-copying sends and numpy arrays</a></li>
<li><a class="reference internal" href="#what-is-sendable">What is sendable?</a><ul>
<li><a class="reference internal" href="#closures">Closures</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#running-code">Running Code</a><ul>
<li><a class="reference internal" href="#apply">Apply</a></li>
<li><a class="reference internal" href="#execute-and-run">execute and run</a></li>
</ul>
</li>
<li><a class="reference internal" href="#views">Views</a><ul>
<li><a class="reference internal" href="#directview">DirectView</a><ul>
<li><a class="reference internal" href="#creating-a-directview">Creating a DirectView</a></li>
<li><a class="reference internal" href="#execution-via-directview">Execution via DirectView</a></li>
<li><a class="reference internal" href="#data-movement-via-directview">Data movement via DirectView</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scatter-and-gather">Scatter and gather</a></li>
<li><a class="reference internal" href="#push-and-pull">Push and pull</a></li>
<li><a class="reference internal" href="#loadbalancedview">LoadBalancedView</a></li>
</ul>
</li>
<li><a class="reference internal" href="#data-movement">Data Movement</a></li>
<li><a class="reference internal" href="#results">Results</a><ul>
<li><a class="reference internal" href="#asyncresults">AsyncResults</a></li>
<li><a class="reference internal" href="#the-mp-pool-asyncresult-interface">The mp.pool.AsyncResult interface</a><ul>
<li><a class="reference internal" href="#extended-interface">Extended interface</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#querying-the-hub">Querying the Hub</a></li>
<li><a class="reference internal" href="#controlling-the-engines">Controlling the Engines</a></li>
<li><a class="reference internal" href="#synchronization">Synchronization</a></li>
<li><a class="reference internal" href="#map">Map</a></li>
<li><a class="reference internal" href="#decorators-and-remotefunctions">Decorators and RemoteFunctions</a></li>
<li><a class="reference internal" href="#dependencies">Dependencies</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="dag_dependencies.html"
                        title="previous chapter">DAG Dependencies</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="parallel_transition.html"
                        title="next chapter">Transitioning from IPython.kernel to IPython.parallel</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/parallel/parallel_details.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="details-of-parallel-computing-with-ipython">
<span id="parallel-details"></span><h1>Details of Parallel Computing with IPython<a class="headerlink" href="#details-of-parallel-computing-with-ipython" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There are still many sections to fill out in this doc</p>
</div>
<div class="section" id="caveats">
<h2>Caveats<a class="headerlink" href="#caveats" title="Permalink to this headline">¶</a></h2>
<p>First, some caveats about the detailed workings of parallel computing with 0MQ and IPython.</p>
<div class="section" id="non-copying-sends-and-numpy-arrays">
<h3>Non-copying sends and numpy arrays<a class="headerlink" href="#non-copying-sends-and-numpy-arrays" title="Permalink to this headline">¶</a></h3>
<p>When numpy arrays are passed as arguments to apply or via data-movement methods, they are not
copied. This means that you must be careful if you are sending an array that you intend to work
on. PyZMQ does allow you to track when a message has been sent so you can know when it is safe
to edit the buffer, but IPython only allows for this.</p>
<p>It is also important to note that the non-copying receive of a message is <em>read-only</em>. That
means that if you intend to work in-place on an array that you have sent or received, you must
copy it. This is true for both numpy arrays sent to engines and numpy arrays retrieved as
results.</p>
<p>The following will fail:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [3]: </span><span class="n">A</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="k">def</span> <span class="nf">setter</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="gp">   ...:</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="gp">   ...:</span> <span class="k">return</span> <span class="n">a</span>

<span class="gp">In [5]: </span><span class="n">rc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">apply_sync</span><span class="p">(</span><span class="n">setter</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="go">---------------------------------------------------------------------------</span>
<span class="go">RemoteError                               Traceback (most recent call last)</span>
<span class="go">...</span>
<span class="go">RemoteError: RuntimeError(array is not writeable)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">  File &quot;/path/to/site-packages/IPython/parallel/streamkernel.py&quot;, line 329, in apply_request</span>
<span class="go">    exec code in working, working</span>
<span class="go">  File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="go">  File &quot;&lt;ipython-input-14-736187483856&gt;&quot;, line 2, in setter</span>
<span class="go">RuntimeError: array is not writeable</span>
</pre></div>
</div>
<p>If you do need to edit the array in-place, just remember to copy the array if it&#8217;s read-only.
The <tt class="xref py py-attr docutils literal"><span class="pre">ndarray.flags.writeable</span></tt> flag will tell you if you can write to an array.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [3]: </span><span class="n">A</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="k">def</span> <span class="nf">setter</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="gp">   ...:</span>     <span class="sd">&quot;&quot;&quot;only copy read-only arrays&quot;&quot;&quot;</span>
<span class="gp">   ...:</span>     <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span><span class="p">:</span>
<span class="gp">   ...:</span>         <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">   ...:</span>     <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="gp">   ...:</span>     <span class="k">return</span> <span class="n">a</span>

<span class="gp">In [5]: </span><span class="n">rc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">apply_sync</span><span class="p">(</span><span class="n">setter</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="gr">Out[5]: </span><span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">])</span>

<span class="c"># note that results will also be read-only:</span>
<span class="gp">In [6]: </span><span class="n">_</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span>
<span class="gr">Out[6]: </span><span class="bp">False</span>
</pre></div>
</div>
<p>If you want to safely edit an array in-place after <em>sending</em> it, you must use the <cite>track=True</cite>
flag. IPython always performs non-copying sends of arrays, which return immediately. You must
instruct IPython track those messages <em>at send time</em> in order to know for sure that the send has
completed. AsyncResults have a <tt class="xref py py-attr docutils literal"><span class="pre">sent</span></tt> property, and <tt class="xref py py-meth docutils literal"><span class="pre">wait_on_send()</span></tt> method for
checking and waiting for 0MQ to finish with a buffer.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [5]: </span><span class="n">A</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">1024</span><span class="p">,</span><span class="mi">1024</span><span class="p">))</span>

<span class="gp">In [6]: </span><span class="n">view</span><span class="o">.</span><span class="n">track</span><span class="o">=</span><span class="bp">True</span>

<span class="gp">In [7]: </span><span class="n">ar</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>

<span class="gp">In [8]: </span><span class="n">ar</span><span class="o">.</span><span class="n">sent</span>
<span class="gr">Out[8]: </span><span class="bp">False</span>

<span class="gp">In [9]: </span><span class="n">ar</span><span class="o">.</span><span class="n">wait_on_send</span><span class="p">()</span> <span class="c"># blocks until sent is True</span>
</pre></div>
</div>
</div>
<div class="section" id="what-is-sendable">
<h3>What is sendable?<a class="headerlink" href="#what-is-sendable" title="Permalink to this headline">¶</a></h3>
<p>If IPython doesn&#8217;t know what to do with an object, it will pickle it. There is a short list of
objects that are not pickled: <tt class="docutils literal"><span class="pre">buffers</span></tt>, <tt class="docutils literal"><span class="pre">str/bytes</span></tt> objects, and <tt class="docutils literal"><span class="pre">numpy</span></tt>
arrays. These are handled specially by IPython in order to prevent the copying of data. Sending
bytes or numpy arrays will result in exactly zero in-memory copies of your data (unless the data
is very small).</p>
<p>If you have an object that provides a Python buffer interface, then you can always send that
buffer without copying - and reconstruct the object on the other side in your own code. It is
possible that the object reconstruction will become extensible, so you can add your own
non-copying types, but this does not yet exist.</p>
<div class="section" id="closures">
<h4>Closures<a class="headerlink" href="#closures" title="Permalink to this headline">¶</a></h4>
<p>Just about anything in Python is pickleable. The one notable exception is objects (generally
functions) with <em>closures</em>. Closures can be a complicated topic, but the basic principal is that
functions that refer to variables in their parent scope have closures.</p>
<p>An example of a function that uses a closure:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
        <span class="c"># inner will have a closure</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="k">return</span> <span class="n">echo</span>

<span class="n">f1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">f2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">f1</span><span class="p">()</span> <span class="c"># returns 1</span>
<span class="n">f2</span><span class="p">()</span> <span class="c"># returns 2</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">f1</span></tt> and <tt class="docutils literal"><span class="pre">f2</span></tt> will have closures referring to the scope in which <cite>inner</cite> was defined,
because they use the variable &#8216;a&#8217;. As a result, you would not be able to send <tt class="docutils literal"><span class="pre">f1</span></tt> or <tt class="docutils literal"><span class="pre">f2</span></tt>
with IPython. Note that you <em>would</em> be able to send <cite>f</cite>. This is only true for interactively
defined functions (as are often used in decorators), and only when there are variables used
inside the inner function, that are defined in the outer function. If the names are <em>not</em> in the
outer function, then there will not be a closure, and the generated function will look in
<tt class="docutils literal"><span class="pre">globals()</span></tt> for the name:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    <span class="c"># note that `b` is not referenced in inner&#39;s scope</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
        <span class="c"># this inner will *not* have a closure</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="k">return</span> <span class="n">echo</span>
<span class="n">g1</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">g2</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">g1</span><span class="p">()</span> <span class="c"># raises NameError on &#39;a&#39;</span>
<span class="n">a</span><span class="o">=</span><span class="mi">5</span>
<span class="n">g2</span><span class="p">()</span> <span class="c"># returns 5</span>
</pre></div>
</div>
<p><cite>g1</cite> and <cite>g2</cite> <em>will</em> be sendable with IPython, and will treat the engine&#8217;s namespace as
globals().  The <tt class="xref py py-meth docutils literal"><span class="pre">pull()</span></tt> method is implemented based on this principal.  If we did not
provide pull, you could implement it yourself with <cite>apply</cite>, by simply returning objects out
of the global namespace:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [10]: </span><span class="n">view</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="n">a</span><span class="p">)</span>

<span class="c"># is equivalent to</span>
<span class="gp">In [11]: </span><span class="n">view</span><span class="o">.</span><span class="n">pull</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="running-code">
<h2>Running Code<a class="headerlink" href="#running-code" title="Permalink to this headline">¶</a></h2>
<p>There are two principal units of execution in Python: strings of Python code (e.g. &#8216;a=5&#8217;),
and Python functions.  IPython is designed around the use of functions via the core
Client method, called <cite>apply</cite>.</p>
<div class="section" id="apply">
<h3>Apply<a class="headerlink" href="#apply" title="Permalink to this headline">¶</a></h3>
<p>The principal method of remote execution is <tt class="xref py py-meth docutils literal"><span class="pre">apply()</span></tt>, of
<a class="reference internal" href="../api/generated/IPython.parallel.client.view.html#IPython.parallel.client.view.View" title="IPython.parallel.client.view.View"><tt class="xref py py-class docutils literal"><span class="pre">View</span></tt></a> objects. The Client provides the full execution and
communication API for engines via its low-level <tt class="xref py py-meth docutils literal"><span class="pre">send_apply_message()</span></tt> method, which is used
by all higher level methods of its Views.</p>
<dl class="docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd>The fuction to be called remotely</dd>
<dt>args <span class="classifier-delimiter">:</span> <span class="classifier">tuple/list</span></dt>
<dd>The positional arguments passed to <cite>f</cite></dd>
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>The keyword arguments passed to <cite>f</cite></dd>
</dl>
<p>flags for all views:</p>
<dl class="docutils">
<dt>block <span class="classifier-delimiter">:</span> <span class="classifier">bool (default: view.block)</span></dt>
<dd><p class="first">Whether to wait for the result, or return immediately.
False:</p>
<blockquote>
<div>returns AsyncResult</div></blockquote>
<dl class="last docutils">
<dt>True:</dt>
<dd><p class="first">returns actual result(s) of f(<a href="#id1"><span class="problematic" id="id2">*</span></a>args, <a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs)
if multiple targets:</p>
<blockquote class="last">
<div>list of results, matching <cite>targets</cite></div></blockquote>
</dd>
</dl>
</dd>
<dt>track <span class="classifier-delimiter">:</span> <span class="classifier">bool [default view.track]</span></dt>
<dd>whether to track non-copying sends.</dd>
<dt>targets <span class="classifier-delimiter">:</span> <span class="classifier">int,list of ints, &#8216;all&#8217;, None [default view.targets]</span></dt>
<dd><p class="first">Specify the destination of the job.
if &#8216;all&#8217; or None:</p>
<blockquote>
<div>Run on all active engines</div></blockquote>
<dl class="last docutils">
<dt>if list:</dt>
<dd>Run on each specified engine</dd>
<dt>if int:</dt>
<dd>Run on single engine</dd>
</dl>
</dd>
</dl>
<p>Note that LoadBalancedView uses targets to restrict possible destinations.  LoadBalanced calls
will always execute in just one location.</p>
<p>flags only in LoadBalancedViews:</p>
<dl class="docutils">
<dt>after <span class="classifier-delimiter">:</span> <span class="classifier">Dependency or collection of msg_ids</span></dt>
<dd>Only for load-balanced execution (targets=None)
Specify a list of msg_ids as a time-based dependency.
This job will only be run <em>after</em> the dependencies
have been met.</dd>
<dt>follow <span class="classifier-delimiter">:</span> <span class="classifier">Dependency or collection of msg_ids</span></dt>
<dd>Only for load-balanced execution (targets=None)
Specify a list of msg_ids as a location-based dependency.
This job will only be run on an engine where this dependency
is met.</dd>
<dt>timeout <span class="classifier-delimiter">:</span> <span class="classifier">float/int or None</span></dt>
<dd>Only for load-balanced execution (targets=None)
Specify an amount of time (in seconds) for the scheduler to
wait for dependencies to be met before failing with a
DependencyTimeout.</dd>
</dl>
</div>
<div class="section" id="execute-and-run">
<h3>execute and run<a class="headerlink" href="#execute-and-run" title="Permalink to this headline">¶</a></h3>
<p>For executing strings of Python code, <tt class="xref py py-class docutils literal"><span class="pre">DirectView</span></tt> &#8216;s also provide an <tt class="xref py py-meth docutils literal"><span class="pre">execute()</span></tt> and
a <tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt> method, which rather than take functions and arguments, take simple strings.
<cite>execute</cite> simply takes a string of Python code to execute, and sends it to the Engine(s). <cite>run</cite>
is the same as <cite>execute</cite>, but for a <em>file</em>, rather than a string. It is simply a wrapper that
does something very similar to <tt class="docutils literal"><span class="pre">execute(open(f).read())</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO: Examples for execute and run</p>
</div>
</div>
</div>
<div class="section" id="views">
<h2>Views<a class="headerlink" href="#views" title="Permalink to this headline">¶</a></h2>
<p>The principal extension of the <tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt> is the <tt class="xref py py-class docutils literal"><span class="pre">View</span></tt>
class. The client is typically a singleton for connecting to a cluster, and presents a
low-level interface to the Hub and Engines. Most real usage will involve creating one or more
<tt class="xref py py-class docutils literal"><span class="pre">View</span></tt> objects for working with engines in various ways.</p>
<div class="section" id="directview">
<h3>DirectView<a class="headerlink" href="#directview" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../api/generated/IPython.parallel.client.view.html#IPython.parallel.client.view.DirectView" title="IPython.parallel.client.view.DirectView"><tt class="xref py py-class docutils literal"><span class="pre">DirectView</span></tt></a> is the class for the IPython <a class="reference internal" href="parallel_multiengine.html#parallel-multiengine"><em>Multiplexing Interface</em></a>.</p>
<div class="section" id="creating-a-directview">
<h4>Creating a DirectView<a class="headerlink" href="#creating-a-directview" title="Permalink to this headline">¶</a></h4>
<p>DirectViews can be created in two ways, by index access to a client, or by a client&#8217;s
<tt class="xref py py-meth docutils literal"><span class="pre">view()</span></tt> method.  Index access to a Client works in a few ways.  First, you can create
DirectViews to single engines simply by accessing the client by engine id:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [2]: </span><span class="n">rc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gr">Out[2]: </span><span class="o">&lt;</span><span class="n">DirectView</span> <span class="mi">0</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>You can also create a DirectView with a list of engines:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [2]: </span><span class="n">rc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gr">Out[2]: </span><span class="o">&lt;</span><span class="n">DirectView</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Other methods for accessing elements, such as slicing and negative indexing, work by passing
the index directly to the client&#8217;s <tt class="xref py py-attr docutils literal"><span class="pre">ids</span></tt> list, so:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="c"># negative index</span>
<span class="gp">In [2]: </span><span class="n">rc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gr">Out[2]: </span><span class="o">&lt;</span><span class="n">DirectView</span> <span class="mi">3</span><span class="o">&gt;</span>

<span class="c"># or slicing:</span>
<span class="gp">In [3]: </span><span class="n">rc</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="gr">Out[3]: </span><span class="o">&lt;</span><span class="n">DirectView</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>are always the same as:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [2]: </span><span class="n">rc</span><span class="p">[</span><span class="n">rc</span><span class="o">.</span><span class="n">ids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
<span class="gr">Out[2]: </span><span class="o">&lt;</span><span class="n">DirectView</span> <span class="mi">3</span><span class="o">&gt;</span>

<span class="gp">In [3]: </span><span class="n">rc</span><span class="p">[</span><span class="n">rc</span><span class="o">.</span><span class="n">ids</span><span class="p">[::</span><span class="mi">2</span><span class="p">]]</span>
<span class="gr">Out[3]: </span><span class="o">&lt;</span><span class="n">DirectView</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Also note that the slice is evaluated at the time of construction of the DirectView, so the
targets will not change over time if engines are added/removed from the cluster.</p>
</div>
<div class="section" id="execution-via-directview">
<h4>Execution via DirectView<a class="headerlink" href="#execution-via-directview" title="Permalink to this headline">¶</a></h4>
<p>The DirectView is the simplest way to work with one or more engines directly (hence the name).</p>
<p>For instance, to get the process ID of all your engines:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [5]: </span><span class="kn">import</span> <span class="nn">os</span>

<span class="gp">In [6]: </span><span class="n">dview</span><span class="o">.</span><span class="n">apply_sync</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">)</span>
<span class="gr">Out[6]: </span><span class="p">[</span><span class="mi">1354</span><span class="p">,</span> <span class="mi">1356</span><span class="p">,</span> <span class="mi">1358</span><span class="p">,</span> <span class="mi">1360</span><span class="p">]</span>
</pre></div>
</div>
<p>Or to see the hostname of the machine they are on:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [5]: </span><span class="kn">import</span> <span class="nn">socket</span>

<span class="gp">In [6]: </span><span class="n">dview</span><span class="o">.</span><span class="n">apply_sync</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">gethostname</span><span class="p">)</span>
<span class="gr">Out[6]: </span><span class="p">[</span><span class="s">&#39;tesla&#39;</span><span class="p">,</span> <span class="s">&#39;tesla&#39;</span><span class="p">,</span> <span class="s">&#39;edison&#39;</span><span class="p">,</span> <span class="s">&#39;edison&#39;</span><span class="p">,</span> <span class="s">&#39;edison&#39;</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO: expand on direct execution</p>
</div>
</div>
<div class="section" id="data-movement-via-directview">
<h4>Data movement via DirectView<a class="headerlink" href="#data-movement-via-directview" title="Permalink to this headline">¶</a></h4>
<p>Since a Python namespace is just a <tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">DirectView</span></tt> objects provide
dictionary-style access by key and methods such as <tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt> and
<tt class="xref py py-meth docutils literal"><span class="pre">update()</span></tt> for convenience. This make the remote namespaces of the engines
appear as a local dictionary. Underneath, these methods call <tt class="xref py py-meth docutils literal"><span class="pre">apply()</span></tt>:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [51]: </span><span class="n">dview</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">,</span><span class="s">&#39;bar&#39;</span><span class="p">]</span>

<span class="gp">In [52]: </span><span class="n">dview</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span>
<span class="gr">Out[52]: </span><span class="p">[</span> <span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="s">&#39;bar&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="s">&#39;bar&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="s">&#39;bar&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="s">&#39;bar&#39;</span><span class="p">]</span> <span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="scatter-and-gather">
<h3>Scatter and gather<a class="headerlink" href="#scatter-and-gather" title="Permalink to this headline">¶</a></h3>
<p>Sometimes it is useful to partition a sequence and push the partitions to
different engines. In MPI language, this is know as scatter/gather and we
follow that terminology. However, it is important to remember that in
IPython&#8217;s <tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt> class, <tt class="xref py py-meth docutils literal"><span class="pre">scatter()</span></tt> is from the
interactive IPython session to the engines and <tt class="xref py py-meth docutils literal"><span class="pre">gather()</span></tt> is from the
engines back to the interactive IPython session. For scatter/gather operations
between engines, MPI should be used:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [58]: </span><span class="n">dview</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="gr">Out[58]: </span><span class="p">[</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">]</span>

<span class="gp">In [59]: </span><span class="n">dview</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span>
<span class="gr">Out[59]: </span><span class="p">[</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">]</span> <span class="p">]</span>

<span class="gp">In [60]: </span><span class="n">dview</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
<span class="gr">Out[60]: </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="push-and-pull">
<h3>Push and pull<a class="headerlink" href="#push-and-pull" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../api/generated/IPython.parallel.client.view.html#IPython.parallel.client.view.DirectView.push" title="IPython.parallel.client.view.DirectView.push"><tt class="xref py py-meth docutils literal"><span class="pre">push()</span></tt></a></p>
<p><a class="reference internal" href="../api/generated/IPython.parallel.client.view.html#IPython.parallel.client.view.DirectView.pull" title="IPython.parallel.client.view.DirectView.pull"><tt class="xref py py-meth docutils literal"><span class="pre">pull()</span></tt></a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO: write this section</p>
</div>
</div>
<div class="section" id="loadbalancedview">
<h3>LoadBalancedView<a class="headerlink" href="#loadbalancedview" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../api/generated/IPython.parallel.client.view.html#IPython.parallel.client.view.LoadBalancedView" title="IPython.parallel.client.view.LoadBalancedView"><tt class="xref py py-class docutils literal"><span class="pre">LoadBalancedView</span></tt></a> is the class for load-balanced execution via the task scheduler.
These views always run tasks on exactly one engine, but let the scheduler determine where that
should be, allowing load-balancing of tasks. The LoadBalancedView does allow you to specify
restrictions on where and when tasks can execute, for more complicated load-balanced workflows.</p>
</div>
</div>
<div class="section" id="data-movement">
<h2>Data Movement<a class="headerlink" href="#data-movement" title="Permalink to this headline">¶</a></h2>
<p>Since the <a class="reference internal" href="../api/generated/IPython.parallel.client.view.html#IPython.parallel.client.view.LoadBalancedView" title="IPython.parallel.client.view.LoadBalancedView"><tt class="xref py py-class docutils literal"><span class="pre">LoadBalancedView</span></tt></a> does not know where execution will take place, explicit
data movement methods like push/pull and scatter/gather do not make sense, and are not provided.</p>
</div>
<div class="section" id="results">
<h2>Results<a class="headerlink" href="#results" title="Permalink to this headline">¶</a></h2>
<div class="section" id="asyncresults">
<h3>AsyncResults<a class="headerlink" href="#asyncresults" title="Permalink to this headline">¶</a></h3>
<p>Our primary representation of the results of remote execution is the <a class="reference internal" href="#AsyncResult" title="AsyncResult"><tt class="xref py py-class docutils literal"><span class="pre">AsyncResult</span></tt></a>
object, based on the object of the same name in the built-in <tt class="xref py py-mod docutils literal"><span class="pre">multiprocessing.pool</span></tt>
module. Our version provides a superset of that interface.</p>
<p>The basic principle of the AsyncResult is the encapsulation of one or more results not yet completed.  Execution methods (including data movement, such as push/pull) will all return
AsyncResults when <cite>block=False</cite>.</p>
</div>
<div class="section" id="the-mp-pool-asyncresult-interface">
<h3>The mp.pool.AsyncResult interface<a class="headerlink" href="#the-mp-pool-asyncresult-interface" title="Permalink to this headline">¶</a></h3>
<p>The basic interface of the AsyncResult is exactly that of the AsyncResult in <tt class="xref py py-mod docutils literal"><span class="pre">multiprocessing.pool</span></tt>, and consists of four methods:</p>
<dl class="class">
<dt id="AsyncResult">
<em class="property">class </em><tt class="descname">AsyncResult</tt><a class="headerlink" href="#AsyncResult" title="Permalink to this definition">¶</a></dt>
<dd><p>The stdlib AsyncResult spec</p>
<dl class="method">
<dt id="AsyncResult.wait">
<tt class="descname">wait</tt><big>(</big><span class="optional">[</span><em>timeout</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#AsyncResult.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until the result is available or until <em>timeout</em> seconds pass. This
method always returns <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="AsyncResult.ready">
<tt class="descname">ready</tt><big>(</big><big>)</big><a class="headerlink" href="#AsyncResult.ready" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the call has completed.</p>
</dd></dl>

<dl class="method">
<dt id="AsyncResult.successful">
<tt class="descname">successful</tt><big>(</big><big>)</big><a class="headerlink" href="#AsyncResult.successful" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the call completed without raising an exception.  Will
raise <tt class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></tt> if the result is not ready.</p>
</dd></dl>

<dl class="method">
<dt id="AsyncResult.get">
<tt class="descname">get</tt><big>(</big><span class="optional">[</span><em>timeout</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#AsyncResult.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result when it arrives.  If <em>timeout</em> is not <tt class="docutils literal"><span class="pre">None</span></tt> and the
result does not arrive within <em>timeout</em> seconds then
<tt class="xref py py-exc docutils literal"><span class="pre">TimeoutError</span></tt> is raised.  If the remote call raised
an exception then that exception will be reraised as a <tt class="xref py py-exc docutils literal"><span class="pre">RemoteError</span></tt>
by <a class="reference internal" href="#AsyncResult.get" title="AsyncResult.get"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a>.</p>
</dd></dl>

</dd></dl>

<p>While an AsyncResult is not done, you can check on it with its <tt class="xref py py-meth docutils literal"><span class="pre">ready()</span></tt> method, which will
return whether the AR is done. You can also wait on an AsyncResult with its <tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt> method.
This method blocks until the result arrives. If you don&#8217;t want to wait forever, you can pass a
timeout (in seconds) as an argument to <tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt>. <tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt> will <em>always return None</em>, and
should never raise an error.</p>
<p><tt class="xref py py-meth docutils literal"><span class="pre">ready()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt> are insensitive to the success or failure of the call. After a
result is done, <tt class="xref py py-meth docutils literal"><span class="pre">successful()</span></tt> will tell you whether the call completed without raising an
exception.</p>
<p>If you actually want the result of the call, you can use <tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt>. Initially, <tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt>
behaves just like <tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt>, in that it will block until the result is ready, or until a
timeout is met. However, unlike <tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt>, <tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt> will raise a <tt class="xref py py-exc docutils literal"><span class="pre">TimeoutError</span></tt> if
the timeout is reached and the result is still not ready. If the result arrives before the
timeout is reached, then <tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt> will return the result itself if no exception was raised,
and will raise an exception if there was.</p>
<p>Here is where we start to expand on the multiprocessing interface. Rather than raising the
original exception, a RemoteError will be raised, encapsulating the remote exception with some
metadata. If the AsyncResult represents multiple calls (e.g. any time <cite>targets</cite> is plural), then
a CompositeError, a subclass of RemoteError, will be raised.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">For more information on remote exceptions, see <a class="reference internal" href="parallel_multiengine.html#parallel-exceptions"><em>the section in the Direct Interface</em></a>.</p>
</div>
<div class="section" id="extended-interface">
<h4>Extended interface<a class="headerlink" href="#extended-interface" title="Permalink to this headline">¶</a></h4>
<p>Other extensions of the AsyncResult interface include convenience wrappers for <tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt>.
AsyncResults have a property, <tt class="xref py py-attr docutils literal"><span class="pre">result</span></tt>, with the short alias <tt class="xref py py-attr docutils literal"><span class="pre">r</span></tt>, which simply call
<tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt>. Since our object is designed for representing <em>parallel</em> results, it is expected
that many calls (any of those submitted via DirectView) will map results to engine IDs. We
provide a <tt class="xref py py-meth docutils literal"><span class="pre">get_dict()</span></tt>, which is also a wrapper on <tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt>, which returns a dictionary
of the individual results, keyed by engine ID.</p>
<p>You can also prevent a submitted job from actually executing, via the AsyncResult&#8217;s
<tt class="xref py py-meth docutils literal"><span class="pre">abort()</span></tt> method. This will instruct engines to not execute the job when it arrives.</p>
<p>The larger extension of the AsyncResult API is the <tt class="xref py py-attr docutils literal"><span class="pre">metadata</span></tt> attribute.  The metadata
is a dictionary (with attribute access) that contains, logically enough, metadata about the
execution.</p>
<p>Metadata keys:</p>
<p>timestamps</p>
<dl class="docutils">
<dt>submitted</dt>
<dd>When the task left the Client</dd>
<dt>started</dt>
<dd>When the task started execution on the engine</dd>
<dt>completed</dt>
<dd>When execution finished on the engine</dd>
<dt>received</dt>
<dd><p class="first">When the result arrived on the Client</p>
<p class="last">note that it is not known when the result arrived in 0MQ on the client, only when it
arrived in Python via <tt class="xref py py-meth docutils literal"><span class="pre">Client.spin()</span></tt>, so in interactive use, this may not be
strictly informative.</p>
</dd>
</dl>
<p>Information about the engine</p>
<dl class="docutils">
<dt>engine_id</dt>
<dd>The integer id</dd>
<dt>engine_uuid</dt>
<dd>The UUID of the engine</dd>
</dl>
<p>output of the call</p>
<dl class="docutils">
<dt>pyerr</dt>
<dd>Python exception, if there was one</dd>
<dt>pyout</dt>
<dd>Python output</dd>
<dt>stderr</dt>
<dd>stderr stream</dd>
<dt>stdout</dt>
<dd>stdout (e.g. print) stream</dd>
</dl>
<p>And some extended information</p>
<dl class="docutils">
<dt>status</dt>
<dd>either &#8216;ok&#8217; or &#8216;error&#8217;</dd>
<dt>msg_id</dt>
<dd>The UUID of the message</dd>
<dt>after</dt>
<dd>For tasks: the time-based msg_id dependencies</dd>
<dt>follow</dt>
<dd>For tasks: the location-based msg_id dependencies</dd>
</dl>
<p>While in most cases, the Clients that submitted a request will be the ones using the results,
other Clients can also request results directly from the Hub. This is done via the Client&#8217;s
<tt class="xref py py-meth docutils literal"><span class="pre">get_result()</span></tt> method. This method will <em>always</em> return an AsyncResult object. If the call
was not submitted by the client, then it will be a subclass, called <tt class="xref py py-class docutils literal"><span class="pre">AsyncHubResult</span></tt>.
These behave in the same way as an AsyncResult, but if the result is not ready, waiting on an
AsyncHubResult polls the Hub, which is much more expensive than the passive polling used
in regular AsyncResults.</p>
<p>The Client keeps track of all results
history, results, metadata</p>
</div>
</div>
</div>
<div class="section" id="querying-the-hub">
<h2>Querying the Hub<a class="headerlink" href="#querying-the-hub" title="Permalink to this headline">¶</a></h2>
<p>The Hub sees all traffic that may pass through the schedulers between engines and clients.
It does this so that it can track state, allowing multiple clients to retrieve results of
computations submitted by their peers, as well as persisting the state to a database.</p>
<p>queue_status</p>
<blockquote>
<div>You can check the status of the queues of the engines with this command.</div></blockquote>
<p>result_status</p>
<blockquote>
<div>check on results</div></blockquote>
<p>purge_results</p>
<blockquote>
<div>forget results (conserve resources)</div></blockquote>
</div>
<div class="section" id="controlling-the-engines">
<h2>Controlling the Engines<a class="headerlink" href="#controlling-the-engines" title="Permalink to this headline">¶</a></h2>
<p>There are a few actions you can do with Engines that do not involve execution.  These
messages are sent via the Control socket, and bypass any long queues of waiting execution
jobs</p>
<p>abort</p>
<blockquote>
<div>Sometimes you may want to prevent a job you have submitted from actually running. The method
for this is <tt class="xref py py-meth docutils literal"><span class="pre">abort()</span></tt>. It takes a container of msg_ids, and instructs the Engines to not
run the jobs if they arrive. The jobs will then fail with an AbortedTask error.</div></blockquote>
<p>clear</p>
<blockquote>
<div>You may want to purge the Engine(s) namespace of any data you have left in it.  After
running <cite>clear</cite>, there will be no names in the Engine&#8217;s namespace</div></blockquote>
<p>shutdown</p>
<blockquote>
<div>You can also instruct engines (and the Controller) to terminate from a Client.  This
can be useful when a job is finished, since you can shutdown all the processes with a
single command.</div></blockquote>
</div>
<div class="section" id="synchronization">
<h2>Synchronization<a class="headerlink" href="#synchronization" title="Permalink to this headline">¶</a></h2>
<p>Since the Client is a synchronous object, events do not automatically trigger in your
interactive session - you must poll the 0MQ sockets for incoming messages.  Note that
this polling <em>does not</em> actually make any network requests.  It simply performs a <cite>select</cite>
operation, to check if messages are already in local memory, waiting to be handled.</p>
<p>The method that handles incoming messages is <tt class="xref py py-meth docutils literal"><span class="pre">spin()</span></tt>. This method flushes any waiting
messages on the various incoming sockets, and updates the state of the Client.</p>
<p>If you need to wait for particular results to finish, you can use the <tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt> method,
which will call <tt class="xref py py-meth docutils literal"><span class="pre">spin()</span></tt> until the messages are no longer outstanding. Anything that
represents a collection of messages, such as a list of msg_ids or one or more AsyncResult
objects, can be passed as argument to wait. A timeout can be specified, which will prevent
the call from blocking for more than a specified time, but the default behavior is to wait
forever.</p>
<p>The client also has an <tt class="docutils literal"><span class="pre">outstanding</span></tt> attribute - a <tt class="docutils literal"><span class="pre">set</span></tt> of msg_ids that are awaiting
replies. This is the default if wait is called with no arguments - i.e. wait on <em>all</em>
outstanding messages.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO wait example</p>
</div>
</div>
<div class="section" id="map">
<h2>Map<a class="headerlink" href="#map" title="Permalink to this headline">¶</a></h2>
<p>Many parallel computing problems can be expressed as a <tt class="docutils literal"><span class="pre">map</span></tt>, or running a single program with
a variety of different inputs. Python has a built-in <tt class="xref py py-func docutils literal"><span class="pre">map()</span></tt>, which does exactly this,
and many parallel execution tools in Python, such as the built-in
<tt class="xref py py-class docutils literal"><span class="pre">multiprocessing.Pool</span></tt> object provide implementations of <cite>map</cite>. All View objects
provide a <tt class="xref py py-meth docutils literal"><span class="pre">map()</span></tt> method as well, but the load-balanced and direct implementations differ.</p>
<p>Views&#8217; map methods can be called on any number of sequences, but they can also take the <cite>block</cite>
and <cite>bound</cite> keyword arguments, just like <tt class="xref py py-meth docutils literal"><span class="pre">apply()</span></tt>, but <em>only as keywords</em>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dview</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">*</span><span class="n">sequences</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li>iter, map_async, reduce</li>
</ul>
</div>
<div class="section" id="decorators-and-remotefunctions">
<h2>Decorators and RemoteFunctions<a class="headerlink" href="#decorators-and-remotefunctions" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO: write this section</p>
</div>
<p><tt class="xref py py-func docutils literal"><span class="pre">&#64;parallel()</span></tt></p>
<p><tt class="xref py py-func docutils literal"><span class="pre">&#64;remote()</span></tt></p>
<p><a class="reference internal" href="../api/generated/IPython.parallel.client.remotefunction.html#IPython.parallel.client.remotefunction.RemoteFunction" title="IPython.parallel.client.remotefunction.RemoteFunction"><tt class="xref py py-class docutils literal"><span class="pre">RemoteFunction</span></tt></a></p>
<p><a class="reference internal" href="../api/generated/IPython.parallel.client.remotefunction.html#IPython.parallel.client.remotefunction.ParallelFunction" title="IPython.parallel.client.remotefunction.ParallelFunction"><tt class="xref py py-class docutils literal"><span class="pre">ParallelFunction</span></tt></a></p>
</div>
<div class="section" id="dependencies">
<h2>Dependencies<a class="headerlink" href="#dependencies" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO: write this section</p>
</div>
<p><tt class="xref py py-func docutils literal"><span class="pre">&#64;depend()</span></tt></p>
<p><tt class="xref py py-func docutils literal"><span class="pre">&#64;require()</span></tt></p>
<p><a class="reference internal" href="../api/generated/IPython.parallel.controller.dependency.html#IPython.parallel.controller.dependency.Dependency" title="IPython.parallel.controller.dependency.Dependency"><tt class="xref py py-class docutils literal"><span class="pre">Dependency</span></tt></a></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="parallel_transition.html" title="Transitioning from IPython.kernel to IPython.parallel"
             >next</a> |</li>
        <li class="right" >
          <a href="dag_dependencies.html" title="DAG Dependencies"
             >previous</a> |</li>
        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../search.html">search</a>|&nbsp;</li>
       <li><a href="../index.html">documentation </a> &raquo;</li>

          <li><a href="index.html" >Using IPython for parallel computing</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2008, The IPython Development Team.
      Last updated on Jul 31, 2011.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1pre.
    </div>
  </body>
</html>